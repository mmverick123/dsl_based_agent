<!-- Generated by SpecStory -->

# 智能客服机器人DSL设计 (2025-12-12 23:57:35)

_**User**_

领域特定语言（DSL）是实现定制化业务流程的核心方法。本作业要求设计一个能够描述特定领域的智能客服机器人的应答逻辑的脚本语言，并实现其解释器。针对来自用户的自然语言，能够调用大语言模型（LLM）API实现意图识别以驱动脚本的解释执行。基本要求：

脚本语言的语法可以自由定义，只要语义上满足描述客服机器人自动应答逻辑的要求。应该给出几种不同的脚本范例，对不同脚本范例解释器执行之后会有不同的行为表现。

选用一种开放API的大语言模型，调用其API对用户的非结构化输入进行意图识别。

程序输入输出形式不限，可以简化为纯命令行界面，程序设计语言使用python

先给出这个项目的需求分析说明与概要设计说明，以及DSL的文法定义，用法说明，范例，不要直接给出代码

---

_**Assistant**_



---

以下内容按“需求分析→概要设计→DSL定义→用法说明→脚本范例”顺序组织，方便报告与后续编码落实。

## 需求分析
- **目标**：构建一个 DSL 与解释器，让客服脚本设计者以高层语言描述机器人问答逻辑，通过 LLM API 做意图识别、槽位提取、动作决策，实现灵活、可扩展的应答流程。
- **用户群体**：企业客服运营、流程设计师、AI 工程师，具备一定技术背景但不必直接写 Python。
- **输入输出**：
  - 输入：终端或 CLI 的用户自然语言；脚本文件作为机器人逻辑配置。
  - 输出：机器人回复文本、可能的结构化动作（如记录工单、交给人工）。
- **核心功能**：
  1. DSL 解析与执行：加载脚本，基于状态机/流程树运行。
  2. LLM 意图识别：调用开放 API（如 OpenAI、Azure、阿里灵积等）解析用户意图。
  3. 变量与上下文管理：保存会话状态、槽位。
  4. 条件分支与流程跳转：根据意图/变量选择不同响应。
  5. 动作执行：回复文本、调用外部服务、发起人工转接等。
- **非功能需求**：
  - 可扩展：便于新增意图、动作。
  - 可测试：脚本可在离线模式用 mock LLM 测试。
  - 安全/容错：LLM 失败时需要降级策略。

## 概要设计
- **模块结构**：
  1. `Parser`：解析 DSL 文本为 AST。
  2. `Executor`：解释执行 AST，管理上下文、状态机。
  3. `LLMClient`：封装 LLM API，提供 `classify_intent()`、`extract_slots()`。
  4. `RuntimeContext`：存储会话变量、环境、日志。
  5. `ActionRegistry`：注册动作（回复、转人工、调用 webhook）。
  6. CLI Shell：读取用户输入，调用解释器获得响应。
- **流程**：
  - 加载脚本 → Parser 生成 AST → Executor 初始化。
  - 每轮对话：CLI 收用户话 → `LLMClient` 返回意图+槽位 → Executor 根据当前节点与条件决定下一步 → 执行动作 → 输出回复并更新上下文。
- **状态管理**：
  - DSL 中定义多个 `state`/`scene`。
  - Executor 维护当前 `state`，根据 `intent` 或 `condition` 切换。
  - 支持回退、结束、转人工等终端状态。

## DSL 文法定义（示例）
采用类 YAML/缩进语法，力求可读性。核心元素：`bot`, `state`, `on_intent`, `action`, `goto`, `fallback` 等。

```
BOT        ::= "bot" BOT_ID NEWLINE STATE_BLOCK+
STATE_BLOCK::= "state" STATE_ID ":" NEWLINE INDENT STATE_BODY DEDENT
STATE_BODY ::= (ENTRY_BLOCK | TRANSITION_BLOCK | FALLBACK_BLOCK)+
ENTRY_BLOCK::= "entry:" NEWLINE INDENT ACTION_LIST DEDENT
TRANSITION_BLOCK ::= "on_intent" INTENT_ID ("," CONDITION)? ":" NEWLINE INDENT ACTION_FLOW DEDENT
CONDITION  ::= "if" EXPR
ACTION_FLOW::= ACTION_LIST (GOTO | END | CONTINUE)?
ACTION_LIST::= ACTION_LINE+
ACTION_LINE::= ACTION_TYPE ("(" ARGS ")")? NEWLINE
GOTO       ::= "goto" STATE_ID NEWLINE
END        ::= "end" NEWLINE
CONTINUE   ::= "continue" NEWLINE
FALLBACK_BLOCK ::= "fallback:" NEWLINE INDENT ACTION_FLOW DEDENT
```

- `EXPR` 支持变量比较、槽位是否存在等简单布尔表达式。
- `ACTION_TYPE` 包含 `reply`, `set`, `call_api`, `handover`, `log` 等（可扩展）。

## DSL 用法说明
1. **定义机器人与状态**：`bot my_support_bot` 开始，状态如 `state greeting`。
2. **入口动作**：`entry` 描述进入状态立刻执行的动作，比如欢迎语。
3. **意图处理**：`on_intent refund_request if slots.amount > 0`，当 LLM 返回意图+槽位满足条件时触发。
4. **动作组合**：`reply("文本")` 输出给用户；`set(var = value)` 更新上下文；`call_api("create_ticket")` 调外部服务。
5. **状态跳转**：使用 `goto next_state`；`end` 结束对话；`continue` 保持当前状态等待下一轮。
6. **兜底策略**：`fallback` 定义未匹配意图或 LLM 异常时执行的流程。
7. **外部配置**：LLM API key、模型名称放在独立配置文件或环境变量。

## DSL 脚本范例
### 范例1：基础问候与FAQ
```
bot simple_bot

state greeting:
  entry:
    reply("您好，我是智能客服，请问需要什么帮助？")

  on_intent faq_hours:
    reply("我们的营业时间是工作日 9:00-18:00。")
    end

  on_intent faq_location:
    reply("门店位于上海市浦东新区XX路。")
    end

  fallback:
    reply("抱歉没理解，您可以问营业时间或地点。")
    continue
```

### 范例2：退款流程含槽位校验
```
bot refund_bot

state greeting:
  entry:
    reply("欢迎来到退款中心，请描述订单问题。")

  on_intent refund_request if slots.order_id and slots.reason:
    set(ticket_reason = slots.reason)
    call_api("fetch_order", order_id = slots.order_id)
    goto verify

  fallback:
    reply("需要订单号和退款原因才能继续。")
    continue

state verify:
  entry:
    reply("已获取订单信息，请确认需退款金额。")

  on_intent confirm_amount if slots.amount > 0:
    set(refund_amount = slots.amount)
    call_api("create_refund", order_id = slots.order_id, amount = slots.amount)
    reply("已提交退款申请，稍后短信通知。")
    end

  fallback:
    reply("请提供正确的退款金额。")
    continue
```

### 范例3：多意图交织与人工转接
```
bot omni_support

state router:
  entry:
    reply("您好，可处理退款、物流、人工等需求。")

  on_intent refund_request:
    goto refund_flow

  on_intent logistics_track:
    goto logistics

  on_intent need_human if context.fail_count >= 2:
    handover("人工客服")
    end

  fallback:
    set(fail_count = context.fail_count + 1)
    reply("暂未识别您的需求，您可以说退款、物流或人工。")
    continue

state refund_flow:
  entry:
    reply("进入退款流程，请提供订单号。")
  ...
```

（`...` 处可继续定义多个状态与动作，展示 DSL 可描述复杂树状流程。）

以上说明可直接用于需求规格文档/设计说明，为后续编码（解析器、执行器、LLM 适配器、CLI）提供清晰蓝图。

---

_**User**_

详细说明一下项目的模块划分，设计模块之间的接口定义

---

_**Assistant**_



---

### 模块划分概览
- **DSL Parser**：把脚本文本转换成结构化 AST；负责语法校验、错误定位。
- **Semantic Model (AST)**：定义 `Bot`, `State`, `Transition`, `Action` 等数据结构，供运行期使用。
- **Executor/Runtime**：解释执行 AST，管理当前状态、变量、动作调度。
- **Runtime Context**：封装会话变量、槽位、系统配置、日志句柄。
- **LLM Client**：统一封装调用的开放 LLM API，输出意图与槽位。
- **Action Registry & Action Handlers**：维护可调用动作（reply、set、call_api、handover 等），提供执行接口。
- **CLI/IO Adapter**：提供命令行交互或其他界面，负责输入输出和会话控制。
- **Config & Resource Manager**：加载模型密钥、脚本文件、mock 数据等。

### 模块接口定义
| 模块 | 关键类/接口 | 说明 |
| --- | --- | --- |
| DSL Parser | `Parser.parse(script_text: str) -> BotDefinition` | 解析脚本；抛出 `DSLParseError`；可接受 `ParsingOptions` 配置缩进等规则。 |
| Semantic Model | 数据类：`BotDefinition`, `StateNode`, `Transition`, `ActionNode`, `ConditionExpr` | 纯数据结构；供 Executor 与工具函数读取。 |
| Executor | `Executor(bot_def: BotDefinition, context: RuntimeContext, llm: LLMClient, registry: ActionRegistry)`<br>`Executor.handle_user_input(text: str) -> List[ActionResult]` | 根据当前状态和 LLM 输出执行流程，返回动作执行结果；内部再调 `context`, `registry`。 |
| Runtime Context | `RuntimeContext` 包含 `session_id`, `variables: Dict`, `slots: Dict`, `history`, `config`；方法 `get_var/set_var`, `push_history`, `reset_state`。 |
| LLM Client | 接口 `LLMClient`: `recognize_intent(utterance: str, context: RuntimeContext) -> IntentResult`（含 `intent`, `confidence`, `slots`）;<br>可有 `LLMClientFactory.from_config(config)`。 |
| Action Registry | `ActionRegistry.register(name: str, handler: Callable)`;<br>`ActionRegistry.execute(name: str, params: Dict, context: RuntimeContext) -> ActionResult` | 支持内建动作和扩展动作。 |
| CLI/IO Adapter | `ConversationShell(executor: Executor)`;<br>`start()` 循环读取输入、调用 `executor.handle_user_input`，将结果输出。 |
| Config Manager | `ConfigLoader.load(path: str) -> ProjectConfig`（含 `script_path`, `llm`, `mock`）；`BotLoader.load_script(config)`。 |

### 模块交互流程
1. `ConfigLoader` 读取配置 → `BotLoader` 使用 `Parser` 解析脚本为 `BotDefinition`。
2. 初始化 `RuntimeContext`、`LLMClient`、`ActionRegistry`，注入到 `Executor`。
3. CLI 调用 `Executor.handle_user_input()`：
   - `Executor` 请求 `LLMClient.recognize_intent()`。
   - 根据当前 `StateNode`、`Transition`，检查条件（访问 `RuntimeContext`）。
   - 调用 `ActionRegistry.execute()` 执行动作，结果写回 `RuntimeContext` 并返回给 CLI。
4. CLI 输出动作结果（通常是 reply 文本），循环下一轮。

### 接口细节示例
- `IntentResult`：`intent_id: str`, `confidence: float`, `slots: Dict[str, Any]`, `raw_output`.
- `ActionResult`：`type: str`, `payload: Dict`, `success: bool`, `message: Optional[str]`.
- `ConditionExpr.evaluate(context: RuntimeContext, slots: Dict) -> bool`。
- `Executor` 提供 `reset()`、`set_state(state_id)` 等辅助方法便于测试。

该接口划分确保 parser/执行/LLM/动作/交互解耦，既利于单元测试又方便替换 LLM 或扩展动作。

---

_**User**_

现在编写项目详细代码，以及需求分析说明，概要设计说明，详细设计说明，解释器支持的DSL脚本编写指南等文档。项目暂时采用命令行界面进行输入输出，LLM API采用通义千问

---

_**Assistant**_



---



---



---

<details>
            <summary>Listed directory undefined • **0** results</summary>
        
No results found
</details>

---



---

```bash
pwd
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> pwd

Path
----
C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent


PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> 
```

---



---

```bash
ls
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> ls


    目录: C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        12/12/2025  11:57 PM                .specstory
-a----        12/12/2025  11:57 PM            113 .cursorindexingignore        


PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> 
```

---



---

```bash
mkdir src,docs,examples
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> mkdir src,docs,examples


    目录: C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        12/16/2025   2:41 PM                src
d-----        12/16/2025   2:41 PM                docs
d-----        12/16/2025   2:41 PM                examples


PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent>
```

---



---

```bash
mkdir src/dsl,src/runtime,src/llm
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> mkdir src/dsl,src/runtime,src/llm


    目录: C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent\src


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        12/16/2025   2:42 PM                dsl
d-----        12/16/2025   2:42 PM                runtime
d-----        12/16/2025   2:42 PM                llm


PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent>
```

---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---



---

```bash
python -m src.cli --script examples/refund_bot.dsl --mock-llm
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> python -m src.cli --script examples/refund_bot.dsl --mock-llm
机器人> 欢迎来到退款中心，请描述订单问题。
用户> 
```

---



---

```bash
Set-Content temp_input.txt "我想退款\n金额100元\nquit"
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> Set-Content temp_input.txt "我想退款\n金额100元\nquit"
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> 
```

---



---

```bash
python -m src.cli --script examples/refund_bot.dsl --mock-llm < temp_input.txt
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> python -m src.cli --script examples/refund_bot.dsl --mock-llm < temp_input.txt
所在位置 行:1 字符: 63
+ ... thon -m src.cli --script examples/refund_bot.dsl --mock-llm < temp_in ... 
+                                                                 ~
“<”运算符是为将来使用而保留的。
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordEx  
   ception
    + FullyQualifiedErrorId : RedirectionNotSupported

PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent>
```

---



---

```bash
Get-Content temp_input.txt | python -m src.cli --script examples/refund_bot.dsl --mock-llm
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> Get-Content temp_input.txt | python -m src.cli --script examples/refund_bot.dsl --mock-llm
机器人> 欢迎来到退款中心，请描述订单问题。
用户> 机器人> 需要提供订单号和退款原因才能继续。
用户>
已终止会话。
对话结束。
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent>
```

---



---

```bash
Remove-Item temp_input.txt
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> Remove-Item temp_input.txt
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent>
```

---



---



---



---

```bash
git status -sb
```

```
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent> git status -sb
## No commits yet on main
?? .cursorindexingignore
?? .specstory/
?? docs/
?? examples/
?? requirements.txt
?? src/
PS C:\Users\aihack\Desktop\学习\程序设计实践\dsl_based_agent>
```

---



---

Read file: undefined

---



---

Read file: undefined

---



---

Read file: undefined

---



---

Read file: undefined

---



---

DSL 解释器链路现已打通：`Parser` 从 DSL 文本生成 AST，`Executor` 结合上下文、动作与 LLM 意图驱动状态机流转，`TongyiLLMClient` 封装通义千问 DashScope API 并提供 JSON 结构化输出，CLI 则负责命令行会话。

```19:153:src/dsl/parser.py
class Parser:
    ...
    def parse(self, script_text: str) -> BotDefinition:
        self.lines = self._tokenize(script_text)
        self.position = 0
        if not self.lines:
            raise DSLParseError("脚本为空", None)
        bot_line = self._consume_line()
        bot_match = re.match(r"bot\s+([A-Za-z0-9_\-]+)$", bot_line.content)
        ...
        while self._has_more():
            line = self._peek_line()
            if not line.content.startswith("state "):
                raise DSLParseError("只允许定义 state 块", line.line_number)
            state = self._parse_state()
            ...
    def _parse_transition(self, line: ParsedLine) -> Transition:
        pattern = r"on_intent\s+([A-Za-z0-9_\-]+)(?:\s+if\s+(.+))?:$"
        ...
        flow = self._parse_flow_block(line.indent, line.line_number)
        return Transition(intent_id=intent_id, condition=condition, flow=flow)
```

```12:147:src/runtime/executor.py
class Executor:
    ...
    def handle_user_input(self, utterance: str) -> List[ActionResult]:
        if not self.is_active:
            return [ActionResult(type="system", payload={}, success=False, message="对话已结束")]
        state = self._current_state()
        self.context.push_user_message(utterance)
        try:
            intent = self.llm.recognize_intent(utterance, self.context, state.list_intents())
        except LLMError as exc:
            return [ActionResult(type="system", payload={}, success=False, message=f"LLM 调用失败: {exc}")]
        self.context.update_slots(intent.slots)
        transition = self._match_transition(state, intent)
        results = self._execute_flow(transition.flow) if transition else self._execute_fallback(state)
        return results
    ...
    def _execute_flow(self, flow: ActionFlow) -> List[ActionResult]:
        results: List[ActionResult] = []
        for action in flow.actions:
            results.extend(self._execute_action(action))
        if flow.goto:
            results.extend(self._enter_state(flow.goto))
        if flow.directive == "end":
            self.is_active = False
            results.append(ActionResult(type="system", payload={}, message="对话结束"))
        return results
```

```25:101:src/llm/tongyi.py
class TongyiLLMClient(LLMClient):
    def __init__(self, api_key: str | None = None, model: str = "qwen-plus") -> None:
        if Generation is None:
            raise ImportError("未安装 dashscope，无法调用通义千问 API")
        self.model = model
        if api_key:
            dashscope.api_key = api_key
    def recognize_intent(...):
        ...
        response = Generation.call(model=self.model, messages=messages, result_format="message")
        if response.status_code != 200:
            raise LLMError(f"LLM 调用失败: {response.code} {response.message}")
        text = self._extract_text(response)
        data = self._parse_json(text)
        return IntentResult(intent_id=data.get("intent", "unknown"), confidence=float(data.get("confidence", 0)), slots=data.get("slots", {}), raw=text)
```

## 文档与示例
- `docs/requirements.md`、`docs/high_level_design.md`、`docs/detailed_design.md` 分别覆盖需求、概要、详细设计。
- `docs/dsl_guide.md` 给出语法、条件、动作、最佳实践。
- `examples/refund_bot.dsl` 演示两阶段退款流程，可直接用于 CLI。
- `requirements.txt` 声明 DashScope 依赖；CLI 通过 `python -m src.cli --script <file> [--mock-llm|--api-key ...]` 启动。

## 测试
- `Get-Content temp_input.txt | python -m src.cli --script examples/refund_bot.dsl --mock-llm`（Mock LLM，自定义输入流模拟两轮对话，验证 CLI 与解释器可运行）。

## 后续建议
- 配置 `DASHSCOPE_API_KEY` 后再运行真实 LLM；无密钥时请使用 `--mock-llm`。
- 如需对接真实系统，可在 `ActionRegistry` 中注册自定义 `call_api`/`handover` Handler。
- 针对复杂条件可考虑自定义安全表达式解析器，进一步增强可控性。

---

_**User**_

需要在dsl编写指南中给出详细完备的文法定义与用法说明

---

_**Assistant**_



---

Read file: undefined

---



---



---



---



---

